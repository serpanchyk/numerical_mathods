<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/third_lab/src/data_handler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/third_lab/src/data_handler.py" />
              <option name="originalContent" value="import numpy as np&#10;from pathlib import Path&#10;import os&#10;&#10;def read_sole_data(input_id):&#10;    input_dir = Path(&quot;..&quot;) / &quot;inputs&quot;&#10;    input_dir.mkdir(parents=True, exist_ok=True)&#10;    npz_path = input_dir / f&quot;input{input_id}.npz&quot;&#10;    txt_path = input_dir / f&quot;input{input_id}.txt&quot;&#10;&#10;    try:&#10;        if os.path.exists(npz_path):&#10;            print(f&quot;Reading data from file {npz_path}...&quot;)&#10;            data = np.load(npz_path)&#10;            if 'a' in data and 'b' in data:&#10;                a = data['a']&#10;                b = data['b']&#10;                print(&quot;Data loaded successfully.&quot;)&#10;                return a, b&#10;            else:&#10;                print(&quot;Error: NPZ file does not contain keys 'a' and 'b'.&quot;)&#10;                return None, None&#10;&#10;        elif os.path.exists(txt_path):&#10;            print(f&quot;Reading data from file {txt_path}...&quot;)&#10;            full_data = np.genfromtxt(txt_path, skip_header=1, delimiter=None, filling_values=0)&#10;            if full_data.ndim &lt; 2:&#10;                print(&quot;Error: Not enough data for matrix and vector.&quot;)&#10;                return None, None&#10;            a = full_data[:, :-1].copy()&#10;            b = full_data[:, -1].copy()&#10;            if a.shape[0] != a.shape[1] or a.shape[0] != b.shape[0]:&#10;                print(&quot;Error: dimensions do not match.&quot;)&#10;                return None, None&#10;            print(&quot;Data loaded successfully.&quot;)&#10;            return a, b&#10;&#10;        else:&#10;            print(&quot;Error: Data file not found.&quot;)&#10;            return None, None&#10;&#10;    except Exception as error:&#10;        print(f&quot;Error reading file: {error}&quot;)&#10;        return None, None&#10;&#10;def method_evaluation(a, x, b, k, rho, norms, execution_time, input_id, method):&#10;    evaluation_dir = Path(&quot;..&quot;) / &quot;evaluations&quot;&#10;    evaluation_dir.mkdir(parents=True, exist_ok=True)&#10;    txt_path = evaluation_dir / f&quot;evaluation{input_id}.txt&quot;&#10;&#10;    try:&#10;        x_benchmark = np.linalg.solve(a, b)&#10;        print(&quot;Benchmark solution successfully calculated.&quot;)&#10;    except np.linalg.LinAlgError:&#10;        x_benchmark = None&#10;        print(&quot;Error: Matrix is singular. Cannot calculate benchmark solution.&quot;)&#10;&#10;    with open(txt_path, 'w') as f:&#10;        f.write(f&quot;Method name: {method.__name__}\n&quot;)&#10;        f.write(f&quot;Machine error for IEEE 754 standard ε ≈ {2.2e-16}\n&quot;)&#10;        f.write(f&quot;Matrix size: {a.shape[0]}\n&quot;)&#10;        f.write(f&quot;Execution time: {execution_time}\n&quot;)&#10;        f.write(f&quot;Count of iterations: {k}\n&quot;)&#10;        f.write(f&quot;Spectral radius: {rho}\n&quot;)&#10;&#10;        cond_a = np.linalg.cond(a)&#10;        f.write(f&quot;Cond A: {cond_a}\n&quot;)&#10;&#10;        for name, value in norms.items():&#10;            f.write(f&quot;{name}: {value}\n&quot;)&#10;&#10;        if x is None:&#10;            print(&quot;Error: No solution found.&quot;)&#10;            f.close()&#10;            return&#10;&#10;        epsilon = 1e-8&#10;        b_perturbed = b + epsilon * np.random.randn(*b.shape)&#10;        x_perturbed, _, _, _ = method(a, b_perturbed,)&#10;        try:&#10;            stability_error = np.linalg.norm(x_perturbed - x)&#10;            f.write(f&quot;Stability error: {stability_error}\n&quot;)&#10;        except RuntimeWarning:&#10;            f.write(&quot;Stability error: Could not be calculated due to divergence.\n&quot;)&#10;&#10;        try:&#10;            residual_norm = np.linalg.norm(a @ x - b)&#10;            relative_residual_norm = residual_norm / np.linalg.norm(a) / np.linalg.norm(x)&#10;            f.write(f&quot;Residual norm of solution: {residual_norm}\n&quot;)&#10;            f.write(f&quot;Relative residual norm: {relative_residual_norm}\n&quot;)&#10;        except RuntimeWarning:&#10;            f.write(&quot;Residual norm of solution: Could not be calculated due to divergence.\n&quot;)&#10;            f.write(&quot;Relative residual norm: Could not be calculated due to divergence.\n&quot;)&#10;&#10;        try:&#10;            abs_error_solution = np.linalg.norm(x - x_benchmark)&#10;            rel_error_solution = abs_error_solution / np.linalg.norm(x_benchmark)&#10;            f.write(f&quot;Absolute error of solution: {abs_error_solution}\n&quot;)&#10;            f.write(f&quot;Relative error of solution: {rel_error_solution}\n&quot;)&#10;        except RuntimeWarning:&#10;            f.write(&quot;Absolute error of solution: Could not be calculated due to divergence.\n&quot;)&#10;            f.write(&quot;Relative error of solution: Could not be calculated due to divergence.\n&quot;)&#10;&#10;        print(f&quot;Evaluation complete. Results saved to {txt_path}'.&quot;)&#10;&#10;def save_solution(x, input_id, decimal_places):&#10;    output_dir = Path(&quot;..&quot;) / &quot;outputs&quot;&#10;    output_dir.mkdir(parents=True, exist_ok=True)&#10;    npz_path = output_dir / f&quot;output{input_id}.npz&quot;&#10;    txt_path = output_dir / f&quot;output{input_id}.txt&quot;&#10;&#10;    if x is not None:&#10;        n = len(x)&#10;        if n &gt; 1000:&#10;            np.savez_compressed(npz_path, x=x)&#10;            print(f&quot;Solution saved to {npz_path}&quot;)&#10;        else:&#10;            np.savetxt(txt_path, x, fmt=f'%.{decimal_places}g')&#10;            print(f&quot;Solution saved to {txt_path}&quot;)&#10;    else:&#10;        with open(txt_path, 'w') as f:&#10;            f.write(&quot;Jacobi method diverged.&quot;)&#10;        print(f&quot;Jacobi method diverged. Saved to {txt_path}&quot;)" />
              <option name="updatedContent" value="import numpy as np&#10;from pathlib import Path&#10;import os&#10;&#10;def read_sole_data(input_id):&#10;    input_dir = Path(&quot;..&quot;) / &quot;inputs&quot;&#10;    input_dir.mkdir(parents=True, exist_ok=True)&#10;    npz_path = input_dir / f&quot;input{input_id}.npz&quot;&#10;    txt_path = input_dir / f&quot;input{input_id}.txt&quot;&#10;&#10;    try:&#10;        if os.path.exists(npz_path):&#10;            print(f&quot;Reading data from file {npz_path}...&quot;)&#10;            data = np.load(npz_path)&#10;            if 'a' in data and 'b' in data:&#10;                a = data['a']&#10;                b = data['b']&#10;                print(&quot;Data loaded successfully.&quot;)&#10;                return a, b&#10;            else:&#10;                print(&quot;Error: NPZ file does not contain keys 'a' and 'b'.&quot;)&#10;                return None, None&#10;&#10;        elif os.path.exists(txt_path):&#10;            print(f&quot;Reading data from file {txt_path}...&quot;)&#10;            full_data = np.genfromtxt(txt_path, skip_header=1, delimiter=None, filling_values=0)&#10;            if full_data.ndim &lt; 2:&#10;                print(&quot;Error: Not enough data for matrix and vector.&quot;)&#10;                return None, None&#10;            a = full_data[:, :-1].copy()&#10;            b = full_data[:, -1].copy()&#10;            if a.shape[0] != a.shape[1] or a.shape[0] != b.shape[0]:&#10;                print(&quot;Error: dimensions do not match.&quot;)&#10;                return None, None&#10;            print(&quot;Data loaded successfully.&quot;)&#10;            return a, b&#10;&#10;        else:&#10;            print(&quot;Error: Data file not found.&quot;)&#10;            return None, None&#10;&#10;    except Exception as error:&#10;        print(f&quot;Error reading file: {error}&quot;)&#10;        return None, None&#10;&#10;def method_evaluation(a, x, b, evals, execution_time, input_id, method):&#10;    &quot;&quot;&quot;&#10;    Write evaluation results to a text file. 'evals' is a dictionary produced by solver&#10;    and may contain keys like:&#10;      iterations, converged, spectral_radius, spectral_vector, cond, norms,&#10;      residual_norm, relative_residual_norm, diagonal_dominance, a_priori_iterations_estimate, epsilon, matrix_size, benchmark (flag)&#10;    If evals.get('benchmark') is True, method_evaluation computes benchmark solution and stability errors.&#10;    &quot;&quot;&quot;&#10;    evaluation_dir = Path(&quot;..&quot;) / &quot;evaluations&quot;&#10;    evaluation_dir.mkdir(parents=True, exist_ok=True)&#10;    txt_path = evaluation_dir / f&quot;evaluation{input_id}.txt&quot;&#10;&#10;    with open(txt_path, 'w') as f:&#10;        f.write(f&quot;Method name: {getattr(method, '__name__', str(method))}\n&quot;)&#10;        f.write(f&quot;Machine error for IEEE 754 standard ε ≈ {2.2e-16}\n&quot;)&#10;        f.write(f&quot;Matrix size: {evals.get('matrix_size', a.shape[0])}\n&quot;)&#10;        f.write(f&quot;Execution time: {execution_time}\n&quot;)&#10;        f.write(f&quot;Iterations: {evals.get('iterations', 'N/A')}\n&quot;)&#10;        f.write(f&quot;Converged: {evals.get('converged', 'N/A')}\n&quot;)&#10;        f.write(f&quot;Epsilon used: {evals.get('epsilon', 'N/A')}\n\n&quot;)&#10;&#10;        # Write simple scalar entries first&#10;        scalar_keys = ['spectral_radius', 'cond', 'residual_norm', 'relative_residual_norm',&#10;                       'a_priori_iterations_estimate', 'diagonal_dominance']&#10;        for key in scalar_keys:&#10;            if key in evals:&#10;                f.write(f&quot;{key}: {evals[key]}\n&quot;)&#10;&#10;        # Norms (nested dict)&#10;        if 'norms' in evals and isinstance(evals['norms'], dict):&#10;            f.write(&quot;\nNorms of iteration matrix C:\n&quot;)&#10;            for nkey, nval in evals['norms'].items():&#10;                f.write(f&quot;  {nkey}: {nval}\n&quot;)&#10;&#10;        # Spectral vector (if present)&#10;        if 'spectral_vector' in evals and evals['spectral_vector'] is not None:&#10;            f.write(&quot;\nSpectral vector (approx):\n&quot;)&#10;            f.write(str(evals['spectral_vector']) + &quot;\n&quot;)&#10;&#10;        # Benchmark solution and solution errors (optional)&#10;        if evals.get('benchmark', False):&#10;            try:&#10;                x_benchmark = np.linalg.solve(a, b)&#10;                abs_err = float(np.linalg.norm(x - x_benchmark))&#10;                rel_err = float(abs_err / np.linalg.norm(x_benchmark)) if np.linalg.norm(x_benchmark) != 0 else None&#10;                f.write(&quot;\nBenchmark solution available.\n&quot;)&#10;                f.write(f&quot;Absolute error vs benchmark: {abs_err}\n&quot;)&#10;                f.write(f&quot;Relative error vs benchmark: {rel_err}\n&quot;)&#10;            except Exception:&#10;                f.write(&quot;\nBenchmark solution could not be computed (singular or unstable matrix).\n&quot;)&#10;&#10;            # Stability test by solving perturbed system directly (does not re-run the iterative method)&#10;            try:&#10;                epsilon = 1e-8&#10;                b_perturbed = b + epsilon * np.random.randn(*b.shape)&#10;                x_perturbed = np.linalg.solve(a, b_perturbed)&#10;                stability_error = float(np.linalg.norm(x_perturbed - x))&#10;                f.write(f&quot;Stability error (solving perturbed system): {stability_error}\n&quot;)&#10;            except Exception:&#10;                f.write(&quot;Stability error: Could not be calculated due to singularity or instability.\n&quot;)&#10;&#10;        f.write(&quot;\nEnd of evaluation.\n&quot;)&#10;&#10;    print(f&quot;Evaluation complete. Results saved to {txt_path}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/third_lab/src/jacobi.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/third_lab/src/jacobi.py" />
              <option name="originalContent" value="import numpy as np&#10;import warnings&#10;&#10;warnings.filterwarnings('ignore', category=RuntimeWarning)&#10;&#10;def try_make_diagonally_dominant(A, b):&#10;    n = A.shape[0]&#10;    permutation = np.zeros(n, dtype=int)&#10;    available_rows = list(range(n))&#10;&#10;    for i in range(n):&#10;        pivot_row = -1&#10;        max_val = -1.0&#10;        for row_idx in available_rows:&#10;            if abs(A[row_idx, i]) &gt; max_val:&#10;                max_val = abs(A[row_idx, i])&#10;                pivot_row = row_idx&#10;&#10;        if pivot_row != -1:&#10;            permutation[i] = pivot_row&#10;            available_rows.remove(pivot_row)&#10;        else:&#10;            return A, b, False&#10;&#10;    A_permuted = A[permutation, :]&#10;    b_permuted = b[permutation]&#10;&#10;    diag_vals = np.abs(np.diag(A_permuted))&#10;    row_sums = np.sum(np.abs(A_permuted), axis=1) - diag_vals&#10;    is_dominant = np.all(diag_vals &gt; row_sums)&#10;&#10;    return A_permuted, b_permuted, is_dominant&#10;&#10;&#10;def solve_jacobi(A, b, eps=1e-10, max_iter_est=100_000):&#10;    initial_diag = np.abs(np.diag(A))&#10;    initial_row_sums = np.sum(np.abs(A), axis=1) - initial_diag&#10;    diag_dom = np.all(initial_diag &gt; initial_row_sums)&#10;&#10;    if not diag_dom:&#10;        print(&quot;Matrix is NOT diagonally dominant. Attempting to reorder rows...&quot;)&#10;        A_new, b_new, success = try_make_diagonally_dominant(A, b)&#10;        if success:&#10;            print(&quot;Successfully reordered matrix to be diagonally dominant.&quot;)&#10;            A, b = A_new, b_new&#10;        else:&#10;            print(&quot;Failed to achieve diagonal dominance through row permutation. Proceeding with original matrix.&quot;)&#10;&#10;    diag = np.diag(A).astype(float)&#10;    if np.any(np.isclose(diag, 0.0)):&#10;        raise ValueError(&quot;Zero (or near-zero) diagonal element detected; cannot apply Jacobi.&quot;)&#10;&#10;    inv_diag = 1.0 / diag&#10;    L = np.tril(A, k=-1)&#10;    R = np.triu(A, k=1)&#10;&#10;    C = -(L + R) * inv_diag[:, np.newaxis]&#10;    d = b * inv_diag&#10;&#10;    try:&#10;        rho = max(abs(np.linalg.eigvals(C)))&#10;    except np.linalg.LinAlgError:&#10;        rho = np.inf&#10;&#10;    norms = {&#10;        &quot;1-norm (col-sum)&quot;: np.linalg.norm(C, ord=1),&#10;        &quot;2-norm (spectral)&quot;: np.linalg.norm(C, ord=2),&#10;        &quot;inf-norm (row-sum)&quot;: np.linalg.norm(C, ord=np.inf)&#10;    }&#10;&#10;    if rho &gt;= 1:&#10;        print(f&quot;WARNING: Spectral radius ρ = {rho:.4f} ≥ 1. The method is expected to diverge.&quot;)&#10;&#10;    x0 = d.copy()&#10;    x1 = C @ x0 + d&#10;    delta = np.linalg.norm(x1 - x0, ord=np.inf)&#10;    norm_C = norms[&quot;inf-norm (row-sum)&quot;]&#10;    k_est = np.inf&#10;&#10;    if norm_C &lt; 1:&#10;        if delta &gt; 1e-15:&#10;            numerator_arg = eps * (1 - norm_C) / delta&#10;            k_est = int(np.ceil(np.log(numerator_arg) / np.log(norm_C)))&#10;            k_est = max(k_est, 1)&#10;            print(f&quot;Estimated number of iterations to reach ε = {eps}: k ≈ {k_est}&quot;)&#10;        else:&#10;            k_est = 1&#10;            print(&quot;Converged immediately on the first step.&quot;)&#10;    else:&#10;        print(&quot;Cannot compute a priori iteration estimate (norm ≥ 1).&quot;)&#10;&#10;    k_max = int(min(k_est if np.isfinite(k_est) else max_iter_est, max_iter_est))&#10;&#10;    k = 0&#10;    x = x0.copy()&#10;&#10;    try:&#10;        for k in range(1, k_max + 1):&#10;            x_new = C @ x + d&#10;            if np.linalg.norm(x_new - x, ord=np.inf) &lt; eps:&#10;                print(f&quot;Converged in {k} iterations.&quot;)&#10;                return x_new, k, rho, norms&#10;            x = x_new&#10;        print(f&quot;Maximum iterations ({k_max}) reached without convergence.&quot;)&#10;    except RuntimeWarning:&#10;        print(&quot;Runtime error during iterations. Possible divergence.&quot;)&#10;&#10;    return x, k, rho, norms" />
              <option name="updatedContent" value="import numpy as np&#10;import warnings&#10;&#10;warnings.filterwarnings('ignore', category=RuntimeWarning)&#10;&#10;def try_make_diagonally_dominant(A, b):&#10;    n = A.shape[0]&#10;    permutation = np.zeros(n, dtype=int)&#10;    available_rows = list(range(n))&#10;&#10;    for i in range(n):&#10;        pivot_row = -1&#10;        max_val = -1.0&#10;        for row_idx in available_rows:&#10;            if abs(A[row_idx, i]) &gt; max_val:&#10;                max_val = abs(A[row_idx, i])&#10;                pivot_row = row_idx&#10;&#10;        if pivot_row != -1:&#10;            permutation[i] = pivot_row&#10;            available_rows.remove(pivot_row)&#10;        else:&#10;            return A, b, False&#10;&#10;    A_permuted = A[permutation, :]&#10;    b_permuted = b[permutation]&#10;&#10;    diag_vals = np.abs(np.diag(A_permuted))&#10;    row_sums = np.sum(np.abs(A_permuted), axis=1) - diag_vals&#10;    is_dominant = np.all(diag_vals &gt; row_sums)&#10;&#10;    return A_permuted, b_permuted, is_dominant&#10;&#10;&#10;def solve_jacobi(A, b, eps=1e-10, max_iter_est=100_000, eval_options=None):&#10;    &quot;&quot;&quot;&#10;    Jacobi solver that returns (x, iterations, evals_dict).&#10;    eval_options: dict to enable/disable specific evaluations. Supported keys:&#10;      'cond', 'spectral_radius', 'spectral_vector', 'norms', 'residual',&#10;      'benchmark', 'a_priori'&#10;    By default all are enabled.&#10;    &quot;&quot;&quot;&#10;    if eval_options is None:&#10;        eval_options = {&#10;            'cond': True,&#10;            'spectral_radius': True,&#10;            'spectral_vector': False,&#10;            'norms': True,&#10;            'residual': True,&#10;            'benchmark': False,&#10;            'a_priori': True&#10;        }&#10;&#10;    evals = {}&#10;    n = A.shape[0]&#10;&#10;    # Diagonal dominance check and optional row reordering&#10;    initial_diag = np.abs(np.diag(A))&#10;    initial_row_sums = np.sum(np.abs(A), axis=1) - initial_diag&#10;    diag_dom = np.all(initial_diag &gt; initial_row_sums)&#10;    evals['diagonal_dominance'] = bool(diag_dom)&#10;&#10;    if not diag_dom:&#10;        A_new, b_new, success = try_make_diagonally_dominant(A.copy(), b.copy())&#10;        evals['reordered_for_dominance'] = bool(success)&#10;        if success:&#10;            A, b = A_new, b_new&#10;            # Update diag dominance flag after reorder&#10;            diag_vals = np.abs(np.diag(A))&#10;            row_sums = np.sum(np.abs(A), axis=1) - diag_vals&#10;            evals['diagonal_dominance'] = bool(np.all(diag_vals &gt; row_sums))&#10;&#10;    diag = np.diag(A).astype(float)&#10;    if np.any(np.isclose(diag, 0.0)):&#10;        raise ValueError(&quot;Zero (or near-zero) diagonal element detected; cannot apply Jacobi.&quot;)&#10;&#10;    inv_diag = 1.0 / diag&#10;    L = np.tril(A, k=-1)&#10;    R = np.triu(A, k=1)&#10;&#10;    C = -(L + R) * inv_diag[:, np.newaxis]&#10;    d = b * inv_diag&#10;&#10;    # spectral radius and spectral vector (if requested)&#10;    rho = None&#10;    spectral_vector = None&#10;    try:&#10;        if eval_options.get('spectral_radius', True) or eval_options.get('spectral_vector', False):&#10;            eigvals = np.linalg.eigvals(C)&#10;            rho = float(np.max(np.abs(eigvals)))&#10;            evals['spectral_radius'] = rho&#10;            if eval_options.get('spectral_vector', False):&#10;                # compute eigenvector for eigenvalue with max modulus&#10;                vals, vecs = np.linalg.eig(C)&#10;                idx = int(np.argmax(np.abs(vals)))&#10;                spectral_vector = vecs[:, idx]&#10;                evals['spectral_vector'] = spectral_vector.tolist()&#10;    except np.linalg.LinAlgError:&#10;        evals['spectral_radius'] = None&#10;        evals['spectral_vector'] = None&#10;        rho = np.inf&#10;&#10;    # Norms&#10;    if eval_options.get('norms', True):&#10;        evals['norms'] = {&#10;            &quot;1-norm (col-sum)&quot;: float(np.linalg.norm(C, ord=1)),&#10;            &quot;2-norm (spectral)&quot;: float(np.linalg.norm(C, ord=2)),&#10;            &quot;inf-norm (row-sum)&quot;: float(np.linalg.norm(C, ord=np.inf))&#10;        }&#10;&#10;    # Condition number (optional)&#10;    if eval_options.get('cond', True):&#10;        try:&#10;            evals['cond'] = float(np.linalg.cond(A))&#10;        except np.linalg.LinAlgError:&#10;            evals['cond'] = None&#10;&#10;    # a priori estimate if possible&#10;    norm_C_inf = evals.get('norms', {}).get('inf-norm (row-sum)', np.linalg.norm(C, ord=np.inf))&#10;    a_priori_iters = None&#10;    if eval_options.get('a_priori', True) and norm_C_inf &lt; 1.0:&#10;        x0 = d.copy()&#10;        x1 = C @ x0 + d&#10;        delta = np.linalg.norm(x1 - x0, ord=np.inf)&#10;        if delta &gt; 0:&#10;            numerator_arg = eps * (1 - norm_C_inf) / delta&#10;            if numerator_arg &gt; 0:&#10;                try:&#10;                    a_priori_iters = int(np.ceil(np.log(numerator_arg) / np.log(norm_C_inf)))&#10;                    a_priori_iters = max(a_priori_iters, 1)&#10;                except Exception:&#10;                    a_priori_iters = None&#10;        evals['a_priori_iterations_estimate'] = None if a_priori_iters is None else int(a_priori_iters)&#10;&#10;    # iteration bounds&#10;    k_est = a_priori_iters if (a_priori_iters is not None) else max_iter_est&#10;    k_max = int(min(k_est if np.isfinite(k_est) else max_iter_est, max_iter_est))&#10;&#10;    # Iteration loop&#10;    x = d.copy()&#10;    converged = False&#10;    k = 0&#10;    for k in range(1, k_max + 1):&#10;        x_new = C @ x + d&#10;        if np.linalg.norm(x_new - x, ord=np.inf) &lt; eps:&#10;            x = x_new&#10;            converged = True&#10;            break&#10;        x = x_new&#10;&#10;    evals['iterations'] = int(k)&#10;    evals['converged'] = bool(converged)&#10;&#10;    # Residuals (optional)&#10;    if eval_options.get('residual', True):&#10;        try:&#10;            residual_norm = float(np.linalg.norm(A @ x - b))&#10;            denom = (np.linalg.norm(A) * np.linalg.norm(x))&#10;            relative_residual = float(residual_norm / denom) if denom != 0 else None&#10;            evals['residual_norm'] = residual_norm&#10;            evals['relative_residual_norm'] = relative_residual&#10;        except Exception:&#10;            evals['residual_norm'] = None&#10;            evals['relative_residual_norm'] = None&#10;&#10;    # Put spectral radius in evals if not already set&#10;    if 'spectral_radius' not in evals:&#10;        try:&#10;            evals['spectral_radius'] = float(np.max(np.abs(np.linalg.eigvals(C))))&#10;        except Exception:&#10;            evals['spectral_radius'] = None&#10;&#10;    # final metadata&#10;    evals['epsilon'] = float(eps)&#10;    evals['matrix_size'] = int(n)&#10;&#10;    return x, int(k), evals" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/third_lab/src/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/third_lab/src/main.py" />
              <option name="originalContent" value="import warnings&#10;import time&#10;import numpy as np&#10;from jacobi import solve_jacobi&#10;from data_handler import read_sole_data, method_evaluation, save_solution&#10;&#10;np.seterr(divide='raise', invalid='raise')&#10;warnings.simplefilter('error', RuntimeWarning)&#10;&#10;INPUT_ID = 2&#10;DECIMAL_PLACES = 60&#10;IS_EVALUATE = True&#10;METHOD = solve_jacobi&#10;EPSILON = 10e-16&#10;&#10;def main():&#10;    a, b = read_sole_data(INPUT_ID)&#10;    if a is None or b is None:&#10;        return&#10;&#10;    start_time = time.time()&#10;    x, k, rho, norms = METHOD(a, b, EPSILON)&#10;    end_time = time.time()&#10;    execution_time = end_time - start_time&#10;&#10;    if IS_EVALUATE:&#10;        method_evaluation(a, x, b, k, rho, norms, execution_time, INPUT_ID, METHOD)&#10;    else:&#10;        print(f&quot;Execution time: {execution_time}\n&quot;)&#10;&#10;    save_solution(x, INPUT_ID, DECIMAL_PLACES)&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;" />
              <option name="updatedContent" value="import warnings&#10;import time&#10;import numpy as np&#10;from jacobi import solve_jacobi&#10;from data_handler import read_sole_data, method_evaluation, save_solution&#10;&#10;np.seterr(divide='raise', invalid='raise')&#10;warnings.simplefilter('error', RuntimeWarning)&#10;&#10;INPUT_ID = 2&#10;DECIMAL_PLACES = 60&#10;IS_EVALUATE = True&#10;METHOD = solve_jacobi&#10;EPSILON = 1e-10&#10;&#10;# Example evaluation options: toggle keys to turn off/on evaluations&#10;EVAL_OPTIONS = {&#10;    'cond': True,&#10;    'spectral_radius': True,&#10;    'spectral_vector': False,&#10;    'norms': True,&#10;    'residual': True,&#10;    'benchmark': True,&#10;    'a_priori': True&#10;}&#10;&#10;def main():&#10;    a, b = read_sole_data(INPUT_ID)&#10;    if a is None or b is None:&#10;        return&#10;&#10;    start_time = time.time()&#10;    x, k, evals = METHOD(a, b, eps=EPSILON, eval_options=EVAL_OPTIONS)&#10;    end_time = time.time()&#10;    execution_time = end_time - start_time&#10;&#10;    if IS_EVALUATE:&#10;        method_evaluation(a, x, b, evals, execution_time, INPUT_ID, METHOD)&#10;    else:&#10;        print(f&quot;Execution time: {execution_time}\n&quot;)&#10;&#10;    save_solution(x, INPUT_ID, DECIMAL_PLACES)&#10;&#10;if __name__ == '__main__':&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>